# 图灵奖第十九届 | 尼克劳斯·维尔特:他用"简洁"重新定义了编程

> **一句话概括**:他创造了Pascal语言让一代人学会编程,提出"维尔特定律"警告软件膨胀,用"算法+数据结构=程序"的公式影响了整个软件工程,是"少即是多"哲学的最佳践行者。

## 🏆 获奖简介

**Niklaus Wirth**(尼克劳斯·维尔特)是一位瑞士计算机科学家,他以极简主义的设计理念和对教育的深切关注而闻名。

- **出生时间**:1934年2月15日
- **出生地点**:瑞士温特图尔
- **获奖年份**:1984年
- **获奖原因**:因其在编程语言设计和开发方面的卓越贡献,特别是Pascal、Modula和Oberon语言的创造。

**为什么他是第十九位?** 在那个软件系统日益复杂、编程语言功能越堆越多的时代,维尔特逆潮流而行,坚持"简洁即力量"。他证明了,通过精心设计的、小而美的语言,可以培养出一代又一代优秀的程序员。他的工作不仅影响了编程教育,更深刻地塑造了我们对软件复杂性的认知。

## 🚀 他的重大贡献

### 1. Pascal语言:一代程序员的启蒙老师

**简单理解**:想象你要教孩子学钢琴。你不会一开始就让他弹肖邦的练习曲,而是从简单的音阶和基础练习开始。Pascal就是编程世界的"音阶练习"——简单、清晰、结构良好,专门为教学而设计。

**Wirth的贡献**:
- **背景**:1960年代末,主流的编程语言要么过于底层(汇编)、要么过于复杂(ALGOL 68)、要么缺乏良好的结构(FORTRAN)。维尔特看到了教学上的巨大空白。
- **灵感**:他参与了ALGOL委员会的工作,但对ALGOL 68日益膨胀的复杂性感到失望。他决定另起炉灶,创造一门真正适合教学的语言。
- **成就**:1970年,Pascal语言诞生。它以17世纪法国数学家和哲学家布莱兹·帕斯卡(Blaise Pascal)命名。
- **核心特点**:
    - **强类型系统**:编译器会在编译时捕获大量错误,帮助学生养成严谨的习惯。
    - **清晰的结构**:明确的`begin...end`块结构、清晰的控制流(if-then-else, while, for),远离混乱的goto。
    - **可读性第一**:代码读起来接近自然语言,易于理解。
    - **紧凑的语言核心**:整个语言规范只有几十页,学生可以在一学期内掌握全部特性。

**为什么重要?**
- **教育革命**:从1970年代到1990年代,Pascal成为全球高校计算机教育的标准语言。无数程序员的第一门语言就是Pascal。
- **工业影响**:虽然定位为教学语言,但Pascal在工业界也大放异彩。Borland的Turbo Pascal和后来的Delphi(Object Pascal)成为Windows桌面应用开发的利器。
- **思想遗产**:Pascal倡导的"结构化编程"、"类型安全"、"模块化设计"等理念,深刻影响了后来的所有现代语言。

**打个比方**:如果说C语言是一把锋利但需要小心使用的瑞士军刀,那么Pascal就是一套设计精良、适合初学者的厨具——安全、易用,却能教会你烹饪的基本功。

### 2. "算法+数据结构=程序":软件工程的黄金公式

**简单理解**:这个公式看似简单,却道出了编程的本质——好的程序,是合适的算法与恰当的数据结构的完美结合。

**Wirth的贡献**:
- **背景**:1970年代,软件开发缺乏系统的方法论,很多程序员凭直觉和经验编程。
- **成就**:1976年,维尔特出版了划时代的著作《Algorithms + Data Structures = Programs》(《算法+数据结构=程序》)。
- **核心思想**:
    - **数据结构决定程序形态**:选择正确的数据结构(数组、链表、树、哈希表),程序的其他部分往往就水到渠成。
    - **算法与数据结构协同设计**:不要先确定数据结构再硬凑算法,或反之。它们应该一起演化。
    - **逐步求精(Stepwise Refinement)**:从高层抽象开始,逐步细化到具体实现。先解决"做什么",再解决"怎么做"。

**为什么重要?**
- **教科书典范**:这本书成为计算机科学教育的经典教材,影响了几代学生。
- **方法论影响**:它为软件工程提供了一个简洁有力的思考框架,至今仍然适用。

### 3. Modula和Modula-2:模块化编程的先驱

**简单理解**:当程序变得越来越大,如何组织代码成为关键问题。Modula就像是给代码提供了"抽屉和文件夹"——清晰地分隔不同的功能模块。

**Wirth的贡献**:
- **背景**:Pascal虽然优秀,但缺乏大规模软件开发必需的模块化和并发特性。
- **成就**:
    - **Modula**(1975):首次引入"模块"(Module)作为语言的核心概念。
    - **Modula-2**(1978):进一步完善,成为一门工业级的系统编程语言。
- **核心特点**:
    - **模块系统**:明确的接口定义(DEFINITION MODULE)和实现分离(IMPLEMENTATION MODULE)。
    - **信息隐藏**:模块内部细节对外不可见,只暴露公开接口。
    - **独立编译**:每个模块可以单独编译,加快大型项目的构建速度。
    - **并发支持**:内置的协程(coroutine)机制,为系统编程提供并发控制。

**为什么重要?**
- **工业应用**:Modula-2被用于开发操作系统、实时系统和嵌入式软件。
- **影响后来语言**:模块化的思想影响了Ada、Modula-3,并间接影响了C++的命名空间、Java的包等概念。

### 4. Oberon:语言与操作系统的极简主义实验

**简单理解**:如果你认为现代操作系统太臃肿,Oberon会让你眼前一亮——一个完整的操作系统,核心代码只有几千行!

**Wirth的贡献**:
- **背景**:1980年代,操作系统越来越复杂。维尔特想证明,简洁的设计同样能造出强大的系统。
- **成就**:与Jürg Gutknecht合作,创造了Oberon语言和Oberon操作系统(1986-1989)。
- **核心特点**:
    - **语言极简**:Oberon语言比Pascal更简洁,去掉了一切"非必要"的特性。
    - **垃圾回收**:内置自动内存管理,在系统语言中属于先驱。
    - **面向对象**:通过类型扩展实现继承和多态,但避免了C++那样的复杂性。
    - **操作系统**:Oberon OS采用统一的文档模型、无窗口管理器的极简GUI,整个系统紧凑高效。

**为什么重要?**
- **证明了可行性**:维尔特证明,不需要数百万行代码,也能造出功能完整的现代系统。
- **学术影响**:Oberon被许多大学用作操作系统教学,因为代码量小,学生能读懂全部实现。

### 5. "维尔特定律":对软件膨胀的警示

**简单理解**:"软件变慢的速度总是比硬件变快的速度更快。"

**Wirth的洞察**:
- **现象观察**:尽管摩尔定律让硬件性能每18个月翻倍,但软件却越来越臃肿、越来越慢。
- **深层原因**:
    - **功能膨胀**:开发者不断添加新特性,却很少删除旧功能。
    - **抽象层累积**:每一层抽象都带来开销,层层叠加导致性能损失。
    - **工程纪律松懈**:依赖硬件进步而忽视算法和数据结构的优化。

**为什么重要?**
- **持续的警醒**:在云计算和移动设备时代,这一定律依然适用。臃肿的软件意味着更高的能耗、更差的用户体验。
- **提倡"软件节食"**:鼓励开发者删繁就简,回归本质。

## 🌍 对世界的深远影响

### 1. 塑造了全球计算机教育
从中国的高中信息学竞赛(早期使用Pascal),到欧美大学的数据结构课程,Pascal及维尔特的教学理念影响了至少两代程序员的学习路径。许多今天的技术领袖,都是从Pascal开始编程之旅的。

### 2. 推动了"结构化编程"革命
与Dijkstra等人一起,维尔特是"结构化编程"运动的核心人物。这场运动终结了混乱的goto语句,建立了清晰的控制流和模块化设计标准,是软件工程走向成熟的关键一步。

### 3. Delphi与RAD工具的兴起
虽然维尔特本人没有参与,但他的Pascal语言经过Borland公司的发展,演化为Delphi(Object Pascal)。Delphi以其强大的可视化开发环境和编译速度,成为1990年代Windows应用开发的主流工具之一,助力了快速应用开发(RAD)的普及。

### 4. 对现代语言设计的影响
Go语言的简洁哲学、Rust的显式内存管理、Swift的清晰语法...这些现代语言在设计时,都或多或少地继承了维尔特"少即是多"的精神。

## 🏆 获奖理由

**ACM官方表彰**:表彰他在编程语言设计和开发方面的卓越贡献,特别是Pascal、Modula和Oberon语言的创造。

**更通俗的理解**:他是编程世界的"极简主义大师"。在一个人人追求"功能丰富"的年代,他坚持"功能精炼"。他用一门门精心雕琢的语言,教会了世界什么是好的程序、好的设计、好的工程师。他证明了,伟大的作品源于克制,而非堆砌。

## 👤 个人生平与传奇

### 生平时间线
- **1934年2月15日**:出生于瑞士温特图尔。
- **1959年**:获得苏黎世联邦理工学院(ETH Zurich)电气工程学士学位。
- **1960年**:获得魁北克拉瓦尔大学硕士学位。
- **1963年**:获得加州大学伯克利分校电气工程与计算机科学博士学位。
- **1963-1967年**:在斯坦福大学任教。
- **1967年**:加入苏黎世大学。
- **1968-1999年**:在ETH Zurich担任计算机科学教授。
- **1970年**:发布Pascal语言。
- **1975年**:创造Modula语言。
- **1978年**:发布Modula-2。
- **1984年**:获得图灵奖。
- **1986-1989年**:与团队开发Oberon语言和操作系统。
- **1999年**:从ETH退休,被授予荣誉教授称号。

### 人格魅力:务实的理想主义者
维尔特是一位真正的"工程师科学家"——他不仅提出理论,更亲自动手实现。
- **极简主义信仰**:他坚信简洁是可靠性和可维护性的前提。
- **教育家情怀**:他始终关注如何培养下一代程序员,语言设计首先考虑的是"可教性"。
- **动手实践者**:从编译器到操作系统,他都亲自编写代码。Oberon系统的许多核心部分就是他本人完成的。
- **批判精神**:他不怕批评主流趋势。对于C++、Java的复杂性,他多次公开表达质疑。

### 经典语录
> "A good designer must rely on experience, on precise, logical thinking; and on pedantic exactness. No magic will do."
> (一个好的设计师必须依靠经验、精确的逻辑思维和严谨的准确性。魔法帮不了忙。)

> "Software gets slower faster than hardware gets faster."
> (软件变慢的速度比硬件变快的速度更快。)——维尔特定律

> "The belief that complex systems require armies of designers and programmers is wrong. A system that is not understood in its entirety, or at least to a significant degree of detail by a single individual, should probably not be built."
> (认为复杂系统需要成群的设计师和程序员是错误的。一个无法被单个人完整理解或至少在相当程度上理解的系统,可能根本就不应该被构建。)

## 🧐 轶事趣闻:与"臃肿"作斗争

### 1. 对ALGOL 68的反叛
维尔特曾是ALGOL委员会的成员,但他对ALGOL 68日益膨胀的设计越来越失望。ALGOL 68的语言规范变得极其复杂,充满了晦涩的符号和难以实现的特性。维尔特公开批评这种设计方向,并退出委员会,转而创造了简洁的Pascal。这是他"用脚投票"的经典案例。

### 2. Oberon:被误解的杰作
Oberon系统在学术界广受赞誉,但在商业上并不成功。许多人觉得它"太简单了",缺乏主流操作系统的丰富功能。但维尔特认为,这恰恰是优点——简单意味着可理解、可验证、可信赖。他的理念超前于时代,今天在嵌入式系统和安全关键系统中,极简设计的价值正被重新认识。

### 3. 对现代IDE的保留态度
维尔特曾表示,现代集成开发环境(IDE)虽然方便,但也让程序员过度依赖工具,失去了对编译、链接等过程的深入理解。他更喜欢简洁的文本编辑器和命令行工具链。这种"返璞归真"的态度,在今天的一些资深开发者中也有共鸣。

## 💭 为什么他值得纪念?

### 1. 他是"可读性第一"理念的先驱
在维尔特之前,很多人写代码只考虑"能运行就行"。维尔特强调,代码首先是写给人看的,其次才是给机器执行的。这一理念已经成为现代软件工程的基本共识。

### 2. 他证明了"约束激发创造力"
通过限制语言特性、保持设计简洁,维尔特反而创造出了更强大、更优雅的系统。这告诉我们,创新不等于堆砌功能,克制本身就是一种力量。

### 3. 他的工作是"经得起时间考验"的典范
Pascal诞生50多年后,其核心思想——强类型、清晰结构、模块化——仍然是编程语言设计的黄金标准。Delphi至今仍有活跃的社区。Oberon的源代码至今仍被用作教学案例。这种持久的生命力,证明了维尔特工作的深刻价值。

## 💡 给开发者的启示

### 1. 优先考虑可读性和简洁性
在编写代码时,问自己:这段代码一个月后我还能看懂吗?新同事能理解吗?

```pascal
// Pascal风格:清晰、自解释
function FindMaximum(numbers: array of Integer): Integer;
var
    i: Integer;
    max: Integer;
begin
    max := numbers[0];
    for i := 1 to High(numbers) do
        if numbers[i] > max then
            max := numbers[i];
    Result := max;
end;
```

相比之下,一些"聪明"但晦涩的写法:
```python
# 过度简洁,牺牲了可读性
m = lambda l: reduce(lambda a,b: a if a>b else b, l)
```

### 2. 选择合适的数据结构
践行"算法+数据结构=程序"。花时间思考数据结构,往往能让算法变得简单。

```pascal
// 示例:使用哈希表(字典)优化查找
// ❌ 用数组存储,每次查找O(n)
// ✅ 用哈希表,查找O(1)
```

### 3. 抵制功能膨胀的诱惑
每当想添加新功能时,问:这真的是必需的吗?能否用现有功能组合实现?能否用更简单的方式解决同样的问题?

### 4. 理解底层,而不只是使用高级抽象
虽然高级语言和框架很方便,但理解编译、内存管理、系统调用等底层机制,能让你成为更好的开发者。试着用C或Pascal这样的语言写一个小项目,体验"贴近机器"的感觉。

## ❓ 常见问题

**Q: Pascal现在还值得学吗?还有人用吗?**
A: 纯粹的Pascal已经很少用于商业开发,但:
1. **教育价值仍在**:许多编程竞赛和入门课程仍使用Pascal,因为它能培养良好的编程习惯
2. **Delphi仍活跃**:Object Pascal(Delphi)仍有相当大的用户群,特别在企业应用和跨平台开发中
3. **思想永不过时**:学习Pascal的真正价值在于理解结构化编程和类型安全的重要性

**Q: 维尔特定律是真的吗?现代软件真的越来越慢吗?**
A: 维尔特定律更多是一种趋势观察而非严格规律:
- **确实存在**:对比1980年代在几KB内存运行的WordStar,和今天动辄GB级的文本编辑器,软件确实变重了
- **但有例外**:像Vim、SQLite这样的软件,几十年保持轻量高效
- **核心教训**:提醒我们不要把硬件进步当成浪费资源的借口

**Q: 为什么维尔特反对C++和Java等流行语言?**
A: 他不是反对它们的存在,而是质疑它们的复杂性:
- **C++**:他认为C++为了向后兼容C和支持多种编程范式,变得过于复杂
- **Java**:虽然比C++简洁,但仍然包含许多他认为不必要的特性
- **他的立场**:复杂性是可靠性的敌人。每增加一个语言特性,都要权衡其必要性

**Q: Oberon为什么没有商业成功?**
A: 几个原因:
1. **生态问题**:缺乏丰富的第三方库和工具
2. **过于极简**:商业用户需要更多"开箱即用"的功能
3. **市场时机**:推出时Windows和Unix已占据主导地位
4. **但价值永存**:Oberon的思想影响了后来的嵌入式系统和安全系统设计

**Q: 如何在现代项目中应用维尔特的理念?**
A: 实用建议:
1. **代码审查关注简洁性**:不只看功能,还要看是否有更简单的实现
2. **定期"减肥"**:每个季度审视代码库,删除未使用的功能和依赖
3. **写文档时解释"为什么"**:好的设计应该能解释每个设计决策的必要性
4. **学习经典小型系统**:读一读SQLite、Redis的源码,看大师如何用小代码办大事

## 📚 延伸阅读

- **《Algorithms + Data Structures = Programs》**(1976):维尔特的经典教材
- **《Compiler Construction》by Wirth**:用Pascal实现的编译器教学书
- **《Project Oberon》**(1992):完整记录Oberon系统的设计与实现
- **《Pascal User Manual and Report》by Wirth & Jensen**:Pascal语言的权威指南
- **论文"Program Development by Stepwise Refinement"**(1971):逐步求精方法论
- **ETH Oberon项目官网**:可下载Oberon系统和源代码
- **视频:Niklaus Wirth访谈**:YouTube上有多个珍贵的访谈视频

---

**总结语**:尼克劳斯·维尔特是一位真正的"简洁大师"。在一个充满诱惑的世界——诱惑我们不断添加功能、追求复杂、依赖工具——他以一生的工作提醒我们:简单、清晰、可理解,才是软件的本质追求。他创造的语言已经成为历史,但他传播的理念永远鲜活。当你下次面对一个复杂的设计决策时,不妨问问自己:"维尔特会怎么做?"答案往往是:让它更简单。
