# 图灵奖第十二届 | John Backus：他发明了FORTRAN，两次解放了程序员

> **一句话概括**：他让程序员从汇编语言中解放出来（FORTRAN），又试图将程序员从冯·诺伊曼架构中解放出来（函数式编程）

## 🏆 获奖简介

**John Warner Backus**（约翰·沃纳·巴克斯）是**高级编程语言的奠基人**。

- **出生时间**：1924年12月3日
- **出生地点**：美国宾夕法尼亚州费城
- **获奖年份**：1977年
- **获奖原因**：在高级编程系统领域的深刻贡献，特别是FORTRAN的设计和实现，以及编程语言规范形式化（BNF）

**为什么是他？** 在1950年代初，编程极其困难，程序员必须用机器语言或汇编语言编写程序。Backus领导的FORTRAN项目改变了这一切，证明了高级语言不仅可行，而且可以生成高效的机器代码。这一成就说服了整个行业接受高级编程语言。

## 🚀 他的重大贡献

### 1. FORTRAN：第一个成功的高级编程语言

**简单理解**：FORTRAN就像编程界的"白话文运动"，让程序员可以用接近数学公式的方式写程序，而不是用晦涩的机器指令。

**1950年代的编程困境**：
- **机器语言**：直接用二进制编码，如`01001010 00001111`，完全不可读
- **汇编语言**：用助记符如`LOAD A, R1; ADD B, R1`，稍好但仍很底层
- **主要问题**：
  - 编程效率极低，一个简单公式需要几十行汇编
  - 易出错，调试困难
  - 不可移植，IBM的程序无法在Univac上运行
  - 需要深入了解硬件细节

**当时的普遍观点**：
许多专家认为：
- 高级语言生成的代码永远不如手工汇编高效
- 程序员必须完全控制硬件才能写出高性能程序
- 编译器太复杂，不可能实现

**Backus的挑战**：
1953年，Backus向IBM上司提出大胆想法：开发"自动编程系统"，让程序员用接近数学符号的方式编程，由计算机自动翻译成高效机器代码。他组建了约10人的团队，开始了这项"不可能完成"的任务。

**FORTRAN的诞生**：
- **时间**：1954-1957年，历时3年多
- **全称**：FORmula TRANslation（公式翻译）
- **目标用户**：科学家和工程师，需要大量数值计算但不想学汇编

**核心创新**：

1. **数学表达式的直接表达**：
   - 汇编：`y = a*x + b*x + c` 需要10多行代码
   - FORTRAN：`Y = A*X + B*X + C` 一行搞定

2. **自动内存管理**：
   - 程序员不需要手动分配和管理内存地址
   - 变量名自动映射到内存位置

3. **编译器优化**（最革命性的部分）：
   - **寄存器分配**：自动决定哪些变量放在快速寄存器中
   - **公共子表达式消除**：识别重复计算，只计算一次
   - **循环优化**：循环不变代码外提、归纳变量优化、循环展开
   - **强度削减**：用快速操作替换慢操作（如用加法替换乘法）

**为什么这些优化如此重要？**
Backus团队必须证明编译器生成的代码可以与手工汇编一样快，甚至更快。他们成功了，这改变了整个行业对高级语言的看法。

**FORTRAN的影响**：
- **1957年发布**：IBM 704上的第一个FORTRAN编译器
- **立即成功**：一年内，超过一半的IBM 704用户转向FORTRAN
- **标准化**：1966年成为第一个被标准化的编程语言
- **持久生命力**：至今仍在使用！许多科学计算库（LAPACK、BLAS）都用FORTRAN编写

**实际应用**：
- **天气预报**：早期数值天气预报模型
- **核物理模拟**：曼哈顿计划后续的核武器模拟
- **航空航天**：NASA的飞行模拟和轨道计算
- **金融建模**：Black-Scholes期权定价模型实现

**为什么FORTRAN能成功？**
- **专注特定领域**：科学计算，不试图解决所有问题
- **性能至上**：不惜代价优化生成的代码
- **务实设计**：贴近用户需求（科学家熟悉的数学符号）
- **完整工具链**：不仅是语言，还包括调试器、库等

### 2. 巴科斯-诺尔范式（BNF）：精确描述编程语言的工具

**简单理解**：BNF就像语言的"化学式"，用严格的数学符号精确描述编程语言的语法规则。

**背景**：
在BNF出现前，编程语言语法用自然语言描述，导致：
- **歧义**：同一段代码可能有多种理解
- **不完整**：边界情况没有明确定义
- **难以实现**：编译器开发者必须猜测设计者意图

**1958年的ALGOL 58**：
Backus参与ALGOL设计时，如何精确描述语法成为难题。他提出了形式化符号系统，后被Peter Naur改进，成为"巴科斯-诺尔范式"（BNF）。

**BNF的核心思想**：
- **终结符**：语言的基本符号（关键字、运算符、标识符）
- **非终结符**：语法结构的名称（"表达式"、"语句"、"程序"）
- **产生式规则**：定义非终结符如何由其他符号组成
- **递归**：规则可引用自身，描述复杂嵌套结构

**示例**：
```bnf
<表达式> ::= <数字> | <表达式> + <表达式> | <表达式> * <表达式>
<数字> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
```

**BNF的强大之处**：
- **无歧义**：严格确定代码是否合法及如何解析
- **可计算性**：可自动生成解析器（Yacc、Bison等工具）
- **可扩展**：容易添加新语法结构
- **教学清晰**：语言教材用BNF精确定义语法

**影响**：
- **编译器理论**：BNF成为编译原理教材核心内容
- **语言设计**：几乎所有现代语言都用BNF或其变体定义语法
- **标准文档**：C、Java、Python等语言官方标准使用BNF

**现代变体**：
- **EBNF**（扩展BNF）：添加重复、可选等简化符号
- **ABNF**（增强BNF）：用于网络协议规范（HTTP、SMTP）
- **PEG**（解析表达文法）：更适合现代解析器实现

### 3. 函数式编程（FP）系统：超越冯·诺伊曼架构

**简单理解**：Backus后半生致力于推广用"数学函数"而不是"指令序列"来描述计算。

**1977年图灵奖演讲**：
Backus获奖时发表了著名演讲：《Can Programming Be Liberated from the von Neumann Style?》（编程能否从冯·诺伊曼风格中解放出来？）。这是函数式编程历史上最重要的文献之一。

**冯·诺伊曼架构的"束缚"**：
Backus认为传统编程语言（包括他设计的FORTRAN）受到冯·诺伊曼架构的过度限制：
- **单一指令流**：程序是顺序执行的指令序列
- **可变状态**：通过不断修改内存变量来工作
- **赋值语句**：`x = x + 1` 在数学上无意义，但在编程中却是核心

**这些限制导致的问题**：
- **并行化困难**：顺序执行很难并行化
- **推理困难**：要理解程序，必须追踪所有变量的状态变化
- **副作用**：函数可能修改全局状态，行为难以预测
- **语义复杂**：赋值、循环、跳转的数学语义很复杂

**Backus的FP系统**：
提出了完全不同的编程范式：
- **纯函数**：无副作用，相同输入总是产生相同输出
- **函数组合**：通过组合简单函数构建复杂功能
- **高阶函数**：函数可作为参数传递和返回值
- **代数法则**：程序变换可用严格数学法则推理

**FP语言的特点**：
1. **无变量**：没有赋值语句，所有值不可变
2. **无循环**：用递归和高阶函数（map、reduce）代替
3. **组合子**：基本函数组合操作
   - **Composition**：`(f ∘ g)(x) = f(g(x))`
   - **Apply-to-all (map)**：对列表每个元素应用函数
   - **Insert (reduce/fold)**：用二元操作符组合列表元素

**为什么FP当时没有"火"？**
- **性能问题**：早期实现效率不高
- **学习曲线**：程序员习惯命令式思维，转向函数式需要彻底改变
- **工具不成熟**：缺乏成熟的编译器、调试器、IDE
- **应用场景**：当时硬件更适合命令式编程

**但Backus的思想深远影响了后世**：
- **ML、Haskell、Erlang**：现代函数式语言受FP思想启发
- **JavaScript、Python、Java**：命令式语言也吸收了函数式特性（map、filter、lambda）
- **并行计算**：MapReduce、Spark等大数据框架本质是函数式思想
- **程序验证**：纯函数更容易形式化验证

### 4. 编译器优化技术的开创

Backus团队开创的编译器优化技术，对整个编译器理论和实践有深远影响。

**开创性的优化技术**：

1. **数据流分析**：
   - 追踪变量在程序中的定义和使用
   - 识别"活跃变量"（后续还会使用）
   - 用于寄存器分配、死代码消除

2. **循环优化**：
   - **循环不变代码外提**：将不依赖循环变量的计算移到循环外
   - **归纳变量优化**：识别线性变化变量，用简单操作替换
   - **循环展开**：减少循环开销，增加并行性

3. **寄存器分配**：
   - 将频繁使用的变量放在快速寄存器中
   - 这是NP完全问题，Backus团队提出了有效启发式方法

4. **强度削减**：
   - 用快速操作替换慢操作
   - 如循环中`i*2`替换为`i+i`或左移

**为什么这些优化如此重要？**
- **说服怀疑者**：使FORTRAN代码可与手工汇编媲美
- **奠定理论基础**：后来的SSA形式、活性分析、图着色寄存器分配都建立在此基础上
- **持续影响**：现代编译器（GCC、LLVM）仍使用这些技术的改进版

## 🌍 对世界的深远影响

### 开启了高级编程语言时代

**FORTRAN之前**：
- 编程是专家工作，需深入了解硬件
- 软件开发效率极低
- 程序不可移植

**FORTRAN之后**：
- 科学家可直接编程，不需成为计算机专家
- 软件开发效率大幅提升
- 程序可移植性大大改善

**催生了一批新语言**：
FORTRAN的成功证明了高级语言的可行性：
- **COBOL (1959)**：面向商业数据处理
- **ALGOL (1958-1960)**：影响了后续几乎所有语言
- **BASIC (1964)**：简化的FORTRAN，让编程更普及
- **C (1972)**：结合高级语言和底层控制

**改变了行业结构**：
- **软件公司兴起**：降低开发门槛，催生独立软件产业
- **程序员职业化**：从硬件工程师副业变成独立职业
- **教育普及**：大学可开设编程课程

### 塑造了编译器技术

**编译器成为独立学科**：
FORTRAN编译器的成功表明，编译器不仅是"翻译"工具，更是复杂的优化系统。

**经典教材的诞生**：
- **《Compilers: Principles, Techniques, and Tools》（龙书）**：编译器教学圣经
- **《Engineering a Compiler》**：更现代的编译器教材

**优化技术的演进**：
- **全局优化**：跨函数优化（内联、过程间分析）
- **并行优化**：自动将串行代码转换为并行（向量化、多线程）
- **即时编译（JIT）**：运行时动态优化（Java HotSpot、JavaScript V8）
- **机器学习辅助**：用ML预测最佳优化策略

### 推动了函数式编程的复兴

**历史背景**：
- **1950-1970年代**：Lisp发明，主要在AI领域使用
- **1977年**：Backus的图灵奖演讲系统阐述函数式哲学
- **1980-1990年代**：Haskell、Erlang等纯函数式语言诞生
- **2000年代至今**：函数式在主流语言中复兴

**现代函数式编程的回响**：
- **多核时代需求**：无副作用特性天然适合并行计算
- **主流语言吸收**：
  - **Python**：列表推导、map/filter/reduce、lambda
  - **JavaScript**：一等公民函数、闭包、Promise/async-await
  - **Java**：Stream API、函数式接口、Optional
  - **C++**：lambda表达式、函数对象
- **大数据处理**：Hadoop MapReduce、Spark RDD都是函数式思想
- **响应式编程**：RxJS、React等，强调不可变数据

### 科学计算的基石

**FORTRAN的持久生命力**：
虽然有了C、Python等现代语言，FORTRAN在科学计算仍活跃：
- **LAPACK、BLAS**：线性代数库，几乎所有科学计算软件的基础（包括NumPy、MATLAB）
- **气候模拟**：全球气候模型大多用FORTRAN
- **计算流体力学**：飞机、汽车空气动力学模拟
- **量子化学**：分子动力学模拟
- **天文物理**：星系演化、黑洞模拟

**为什么FORTRAN仍流行？**
- **遗留代码**：几十年验证过的代码，重写成本太高
- **性能优势**：编译器对数值计算优化极好
- **数组操作**：对多维数组支持自然高效
- **持续演进**：多个标准版本（FORTRAN 77, 90, 95, 2003, 2008, 2018）

## 🏆 获奖理由

**ACM官方表彰**："表彰他在高级编程系统领域的深刻、有影响力和持久的贡献，特别是通过他领导FORTRAN的设计和实现，以及在编程语言规范形式化方面的工作。"

**更通俗的理解**：
Backus改变了编程历史进程。他通过FORTRAN，将编程从少数专家的专属技能变成科学家和工程师可掌握的工具。当大多数人沉浸在命令式编程的成功中时，他勇敢反思和批判，提出函数式编程这一全新范式，为未来编程语言发展指明方向。

**历史意义**：Backus体现了科学家最可贵的品质——创新、反思、求变。他不满足于过去的成就，不断追求更好的编程方式。

## 👤 个人生平与传奇

### 生平时间线

- **1924年12月3日**：出生于费城
- **1940年代**：在弗吉尼亚大学学化学，成绩不佳被开除，参军服役
- **二战后**：在纽约广播修理店工作时对数学产生兴趣
- **1949-1950年**：哥伦比亚大学获学士和硕士学位
- **1950年**：加入IBM，最初为SSEC编写程序
- **1953年**：向上司提出开发FORTRAN的想法
- **1954-1957年**：领导团队开发FORTRAN编译器
- **1957年**：FORTRAN首次发布，立即获得成功
- **1960年代**：参与ALGOL设计，提出BNF
- **1970年代**：研究函数式编程，开发FP系统
- **1977年**：获得图灵奖
- **1991年**：从IBM退休，继续研究和写作
- **2007年3月17日**：逝世，享年82岁

### 性格与风格

- **谦逊**：尽管功勋卓著，始终保持谦逊，强调团队贡献
- **批判精神**：不满足现状，敢于质疑自己的成就
- **追求简洁**：无论语言设计还是编程理念，都追求简洁优雅
- **理想主义**：FP系统虽无商业成功，但体现了对"完美编程语言"的追求

### 经典语录

> "Much of my work has come from being lazy. I didn't like writing programs."
> （我的很多工作都源于懒惰。我不喜欢写程序。）

这体现了Backus的幽默和务实——最好的工具往往源于解决实际问题的需求。

> "You need the willingness to fail all the time."
> （你需要愿意不断失败。）

揭示了创新的本质——不怕失败，持续尝试。

> "If you are not failing a lot, you are probably not being as creative as you could be."
> （如果你没有频繁失败，你可能没有发挥出创造力。）

对创造性工作的深刻见解，失败是创新的必经之路。

## 💭 为什么他值得纪念？

### 1. 改变了编程的本质
他让编程从"硬件操作"变成了"算法表达"：
- 每当你用高级语言编程，都在受益于FORTRAN的遗产
- 每当编译器优化代码，都在使用他开创的技术
- 每当你用BNF定义语法，都在使用他创造的工具

### 2. 两次革命性的尝试
- **第一次革命**（FORTRAN）：成功，改变了整个行业
- **第二次革命**（函数式编程）：当时未成功，但影响深远

这种不满足于过去成就、持续探索的精神值得敬佩。

### 3. 理论与实践的完美结合
- **FORTRAN**：务实的成功，解决了实际问题
- **BNF**：理论的优雅，提供了严格的形式化工具
- **FP**：理想的探索，指明了未来方向

### 4. 影响了几代程序员
- FORTRAN教会了第一代科学家编程
- BNF教会了编译器设计者如何精确定义语言
- FP思想影响了现代所有主流语言

---

**总结语**：John Backus是一位改变编程历史进程的伟人。他用FORTRAN让编程变得可及，用BNF让语言定义变得精确，用FP思想为编程的未来指明方向。作为图灵奖第十二届获奖者，他证明了创新需要勇气——既要有推翻旧世界的勇气（从汇编到高级语言），也要有反思自己成就的勇气（批判命令式编程）。他的一生是创新和自我超越的典范。

## 🧭 时代背景：计算机的青春期

### 硬件爆发，软件滞后
1950年代，计算机硬件快速发展（从真空管到晶体管），但软件开发仍是瓶颈。程序员花费90%时间在调试低级代码上。

### 科学计算的需求
冷战、核武器研究、太空竞赛都需要大量数值计算，迫切需要提高编程效率。

### 商业化的开始
IBM等公司开始向企业销售计算机，但没有足够的专业程序员。需要让非专家也能编程。

### Backus的机遇
他在正确的时间、正确的地点（IBM），有正确的技能（数学和编程），抓住了这个历史机遇。

## 🔬 FORTRAN深入拆解

### 1) 语言设计的权衡

**科学计算优先**：
- 强大的数学表达式
- 多维数组原生支持
- 高效的数值计算

**牺牲的特性**：
- 字符串处理弱
- 没有指针（早期版本）
- 缺乏数据结构

### 2) 编译器的挑战

**目标**：生成与手工汇编一样快的代码

**关键技术**：
- **三地址代码**：中间表示，便于优化
- **基本块分析**：将程序分成无分支的代码块
- **活性分析**：确定变量何时需要保存
- **寄存器分配**：用图着色算法（后来的改进）

### 3) FORTRAN的演进

每个版本都在保持向后兼容的同时添加新特性：
- **FORTRAN 66**：第一个标准，固化了基本特性
- **FORTRAN 77**：添加块if、字符串处理
- **FORTRAN 90**：现代化大改，添加模块、指针、动态数组
- **FORTRAN 2003**：面向对象特性
- **FORTRAN 2018**：并行计算、协数组

## 💡 给今天开发者的启示

### 理解抽象的价值
- **高级抽象**：让你专注于"做什么"而不是"怎么做"
- **性能成本**：理解抽象的代价，在需要时优化
- **选择合适的抽象层次**：不同场景需要不同抽象

### 拥抱函数式思维
- **纯函数**：更容易测试、推理、并行化
- **不可变数据**：避免很多bug
- **组合优于继承**：用函数组合构建复杂功能

### 学习编译器原理
- **理解代码如何执行**：帮助你写出更高效的代码
- **工具链的重要性**：好的语言需要好的工具支持
- **优化的极限**：知道编译器能做什么、不能做什么

### 不要停止创新
- **质疑现状**：即使是成功的解决方案也有局限
- **拥抱失败**：创新必然伴随失败
- **长远思考**：今天的实验可能是明天的标准

## 📚 推荐阅读与资料

### 核心论文
- **《Can Programming Be Liberated from the von Neumann Style?》(1978)** - John Backus
  图灵奖演讲，必读经典

- **《The History of Fortran I, II, and III》(1978)** - John Backus
  Backus亲自撰写的FORTRAN历史

### 经典教材
- **《Structure and Interpretation of Computer Programs (SICP)》** - Abelson & Sussman
  深入讲解函数式编程和程序抽象

- **《Compilers: Principles, Techniques, and Tools (龙书)》** - Aho等
  详细介绍Backus团队开创的优化技术

- **《Programming Language Pragmatics》** - Michael L. Scott
  全面介绍编程语言设计和实现

### 函数式编程
- **《Learn You a Haskell for Great Good!》** - Miran Lipovača
  Haskell有趣入门书

- **《Functional Programming in Scala》** - Chiusano & Bjarnason
  深入函数式编程概念

### 在线资源
- **LLVM教程**：学习现代编译器技术
- **Coursera: Programming Languages**：Dan Grossman的优秀课程
- **YouTube: "Growing a Language" by Guy Steele**：另一位语言设计大师的演讲

## 🧾 致敬：永不停止的创新

阅读Backus的故事，你会发现三个关键词：
- **解放**：从机器细节到数学抽象
- **反思**：质疑自己最成功的作品
- **探索**：追求更优雅的编程方式

他的工作提醒我们：最好的技术往往来自对重复劳动的厌倦。Backus说他开发FORTRAN是因为"懒得写程序"——这种"懒惰"恰恰是推动技术进步的动力。

当你下次写代码时，请记住：你正站在Backus的肩膀上。每一个高级语言特性、每一次编译器优化、每一个函数式风格的代码，都回响着这位先驱70年前的创新。

**致敬，John Backus！**
**致敬，让编程变得优雅的革命者！**
